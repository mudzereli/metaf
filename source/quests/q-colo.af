~~ {
~~ FOR AUTO-COMPLETION ASSISTANCE: testvar getvar setvar touchvar clearallvars clearvar getcharintprop getchardoubleprop getcharquadprop getcharboolprop getcharstringprop getisspellknown getcancastspell_hunt getcancastspell_buff getcharvital_base getcharvital_current getcharvital_buffedmax getcharskill_traininglevel getcharskill_base getcharskill_buffed getplayerlandcell getplayercoordinates coordinategetns coordinategetwe coordinategetz coordinatetostring coordinateparse coordinatedistancewithz coordinatedistanceflat wobjectgetphysicscoordinates wobjectgetname wobjectgetobjectclass wobjectgettemplatetype wobjectgetisdooropen wobjectfindnearestmonster wobjectfindnearestdoor wobjectfindnearestbyobjectclass wobjectfindininventorybytemplatetype wobjectfindininventorybyname wobjectfindininventorybynamerx wobjectgetselection wobjectgetplayer wobjectfindnearestbynameandobjectclass actiontryselect actiontryuseitem actiontryapplyitem actiontrygiveitem actiontryequipanywand actiontrycastbyid actiontrycastbyidontarget chatbox chatboxpaste statushud statushudcolored uigetcontrol uisetlabel isfalse istrue iif randint cstr strlen getobjectinternaltype cstrf stopwatchcreate stopwatchstart stopwatchstop stopwatchelapsedseconds cnumber floor ceiling round abs getworldname getitemcountininventorybyname getheading getitemcountininventorybynamerx getheadingto actiontrygiveprofile vitae getfellowshipstatus getfellowshipname getfellowshipisopen getfellowshipisleader getfellowshipleaderid getfellowshipcanrecruit getfellowid getfellowshipcount getfellowshiplocked getfellowname getfellowshipisfull sin cos tan sqrt asin acos atan atan2 sinh cosh tanh vtsetmetastate getregexmatch echo chr ord wobjectgetid wobjectgethealth wobjectfindbyid wobjectgetintprop wobjectfindnearestbytemplatetype wobjectgetopencontainer testquestflag getquestktprogress isrefreshingquests getquestktrequired getqueststatus getisday getgamehour getgamehourname getisnight getgameday getgameticks getminutesuntilday getgamemonth getgamemonthname getminutesuntilnight getgameyear uisetvisible uiviewvisible uiviewexists getgvar touchgvar getpvar touchpvar setgvar cleargvar setpvar clearpvar testgvar clearallgvars testpvar clearallpvars dictgetitem dictcreate dicthaskey dictadditem dictkeys dictremovekey dictvalues dictclear dictsize dictcopy listgetitem listpop listcreate listcontains listremove listadd listindexof listremoveat listinsert listlastindexof listclear listcopy listcount listreverse

~~																						
~~ File auto-generated by metaf, a program created by Eskarina of Morningthaw/Coldeve.	
~~		Get metaf here: https://github.com/JJEII/metaf/									
~~																						
~~ All recognized structural designators:												
~~		STATE:				DO:															
~~		IF:					NAV:														
~~																						
~~ All recognized CONDITION (IF:) operation keywords:									
~~		Never				NavEmpty			MobsInDist_Priority		Not				
~~		Always				Death				NeedToBuff				PSecsInStateGE	
~~		All					VendorOpen			NoMobsInDist			SecsOnSpellGE	
~~		Any					VendorClosed		BlockE					BuPercentGE		
~~		ChatMatch			ItemCountLE			CellE					DistToRteGE		
~~		MainSlotsLE			ItemCountGE			IntoPortal				Expr			
~~		SecsInStateGE		MobsInDist_Name		ExitPortal				ChatCapture		
~~																						
~~ All recognized ACTION (DO:) operation keywords:										
~~		None				EmbedNav			ChatExpr				SetOpt			
~~		SetState			CallState			SetWatchdog				CreateView		
~~		Chat				Return				ClearWatchdog			DestroyView		
~~		DoAll				DoExpr				GetOpt					DestroyAllViews	
~~																						
~~ All recognized NAV types:															
~~		circular			follow														
~~		linear				once														
~~																						
~~ All recognized NAV NODE types:														
~~		flw					vnd															
~~		pnt					ptl															
~~		rcl					tlk															
~~		pau					chk															
~~		cht					jmp															
~~		prt (deprecated in VTank)														
~~ }

STATE: {Default} ~~ {
	IF:	Always
		DO:	SetState {*SetupOptions*}
~~ }
STATE: {*SetupOptions*} ~~ {
	IF:	Always
		DO:	DoExpr {echo[`[META]: Setting up for Colosseum`,19]}
	IF:	Always
		DO:	DoAll
				EmbedNav navNone {None}
				SetOpt {LootOnlyRareCorpses} {false}
				SetOpt {LootPriorityBoost} {true}
				SetOpt {EnableBuffing} {false}
				SetOpt {AttackDistance} {0.13333}
				SetOpt {ApproachDistance} {0.13333}
				SetOpt {CorpseApproachRange-Max} {0.13333}
				SetOpt {NavCloseStopRange} {0.01}
				SetOpt {EnableCombat} {false}
				SetOpt {PetRangeMode} {0}
				SetOpt {EnableNav} {true}
				SetOpt {LootFellowCorpses} {false}
				SetOpt {CastDispelSelf} {false}
				SetOpt {SummonPets} {true}
				DoExpr {&qcolo_managed_encaps=1}
				DoExpr {&qcolo_allowsolo=1}
				DoExpr {&qcolo_enablebuffing=1}
				DoExpr {&qcolo_chars=listcreate[]}
				DoExpr {&qcolo_charswaiting=listcreate[]}
				DoExpr {&qcolo_charsbuffed=listcreate[]}
				DoExpr {&qcolo_charsreadyforturnin=listcreate[]}
				DoExpr {&qcolo_fellowlocked=0}
				DoExpr {&qcolo_looping=0}
				DoExpr {$colosseum_recall=4213}
				SetState {ProgressCheck}
~~ }
STATE: {ProgressCheck} ~~ {
	IF:	Always
		DO:	DoExpr {echo[`[META]: Checking Progress`,19]}
	IF:	Expr {$arenabell=wobjectfindnearestbynameandobjectclass[37,Arena Bell]&&coordinatedistancewithz[getplayercoordinates[], wobjectgetphysicscoordinates[$arenabell]] <= 25}
		DO:	SetState {StartCurrentRoom}
	IF:	BlockE 00AF0000
		DO:	SetState {WaitingForCommands}
	IF:	Always
		DO:	SetState {GoToColo}
~~ }
STATE: {GoToColo} ~~ {
	IF:	Always
		DO:	DoExpr {echo[`[META]: Recalling to Colosseum`,19]}
	IF:	BlockE 00AF0000
		DO:	SetState {ProgressCheck}
	IF:	All
			Expr {actiontryequipanywand[]}
			Expr {actiontrycastbyid[$colosseum_recall]}
			Never
		DO: None
~~ }
STATE: {WaitingForCommands} ~~ {
	IF:	Always
		DO: EmbedNav navTalkMasterArbitrator {TalkMasterArbitrator}
	IF:	All
			NavEmpty
			SecsInStateGE 3
		DO:	DoAll
				DoExpr {echo[`[META]: Waiting for Commands`,19]}
				DoExpr {echo[`[META]: Following commands are available:`,19]}
				DoExpr {echo[`[META]: !start - start the colo run`,19]}
				DoExpr {echo[`[META]: !startl - start the colo run, but loop & keep going after finishing`,19]}
				DoExpr {echo[`[META]: !tickets - buy colo tickets`,19]}
				DoExpr {echo[`[META]: !times - see time to complete rooms in last run`,19]}
	~~ this condition is used to manually start the script [!startl in fellow] (with looping)
	IF:	Any
			ChatMatch {\[Fellowship\] (You say|.* says)\, \"\!startl\"}
			Expr {&qcolo_looping}
		DO:	DoAll
				DoExpr {&qcolo_looping=1}
				SetState {SynchronizeChars}
	~~ this condition is used to manually start the script [!start in fellow] (without looping)
	IF:	ChatMatch {\[Fellowship\] (You say|.* says)\, \"\!start\"}
		DO:	SetState {SynchronizeChars}
	~~ this condition is used to start buying tickets
	IF:	ChatMatch {\[Fellowship\] You say\, \"\!tickets\"}
		DO:	SetState {BuyTickets}
	~~ this condition is used check room times
	IF:	ChatMatch {\[Fellowship\] You say\, \"\!times\"}
		DO:	SetState {AnnounceRoomTimes}
~~ }
STATE: {SynchronizeChars} ~~ {
	IF:	Always
		DO:	DoExpr {echo[`[META]: Synchronizing Colosseum Meta on all Characters`,19]}
	IF:	Not Expr {getfellowshipcount[]>=3||&qcolo_allowsolo}
		DO:	DoAll
				DoExpr {echo[`[META]: Must have 3 Characters in Fellow or be in Solo Mode`,19]}
				SetState {WaitingForCommands}
	IF:	All
			Expr {listcontains[&qcolo_chars,getcharstringprop[1]]||listadd[&qcolo_chars,getcharstringprop[1]]}
			Never
		DO:	None
	IF:	SecsInStateGE 8
		DO:	DoAll
				DoExpr {echo[`[META]: Starting Colosseum with `+listcount[&qcolo_chars]+` Characters!`,19]}
				SetState {SynchronizeWaitingForStart}
~~ }
STATE: {SynchronizeWaitingForStart} ~~ {
	IF: Always
		DO:	DoExpr {echo[`[META]: Synchronizing all Characters @ Waiting For Start`,19]}
	IF: Expr {listcount[&qcolo_charswaiting]>=listcount[&qcolo_chars]}
		DO:	DoAll
				DoExpr {echo[`[META]: Synchronized `+listcount[&qcolo_charswaiting]+` Characters @ Waiting For Start`,19]}
				SetState {WaitingForStart}
	IF:	All
			Expr {listcontains[&qcolo_charswaiting,getcharstringprop[1]]||listadd[&qcolo_charswaiting,getcharstringprop[1]]}
			Never
		DO:	None
~~ }
STATE: {WaitingForStart} ~~ {
	IF: Always
		DO:	DoExpr {echo[`[META]: Waiting For Start`,19]}
	~~ this sets up all the initial variables when waiting to start
	IF:	Always
		DO:	DoAll
				DoExpr {setgvar[qcolo_charsreadyforturnin,listcreate[]]}
				SetOpt {EnableCombat} {false}
				SetOpt {EnableLooting} {false}
				EmbedNav navTalkMasterArbitrator {TalkMasterArbitrator}
	~~ this condition triggers when the ticket holder receives a ticket stub
	IF:	Any
			Expr {&qcolo_fellowlocked}
			ChatMatch {\[Fellowship\].* says\, \"Received a Colosseum Ticket Stub\. Enter the first room and start buffing\!"}
			ChatMatch {Master Arbitrator tells you\, \"Your fellowship\'s Arena battles still continue. }
		DO:	SetState {EnterFirstRoom}
	~~ this condition will automatically start the next run if qcolo_looping is set to 1
	IF:	ItemCountGE 1 {Colosseum Ticket}
		DO:	SetState {TicketCheck}
~~ }
STATE: {TicketCheck} ~~ {
	IF:	Always
		DO:	DoExpr {echo[`[META]: Checking Tickets for Entry`,19]}
	~~ if we get a ticket stub, start buffing and notify clients that it was received
	IF:	ItemCountGE 1 {Colosseum Ticket Stub}
		DO:	DoAll
				DoExpr {&qcolo_fellowlocked=1}
				Chat {/f Received a Colosseum Ticket Stub. Enter the first room and start buffing!}
				SetState {EnterFirstRoom}
	~~ if we have a ticket but no stub, try to get a ticket
	IF:	All
			ItemCountGE 1 {Colosseum Ticket}
			Not ItemCountGE 1 {Colosseum Ticket Stub}
		DO:	Chat {/ub give Colosseum Ticket to Master Arbitrator}
	~~ if we're out of tickets, we're all done
	IF:	All
			ItemCountLE 0 {Colosseum Ticket Stub}
			ItemCountLE 0 {Colosseum Ticket}
		DO:	SetState {WaitingForCommands}
	~~ keep trying to get a ticket until an arena frees up
	IF:	All
			ItemCountLE 0 {Colosseum Ticket Stub}
			Any
				SecsInStateGE 10
				ChatMatch {^Master Arbitrator says\, \"Arena .* is now available for new warriors\!\"}
		DO:	SetState {TicketCheck}
~~ }
STATE: {EnterFirstRoom} ~~ {
	IF:	Always
		DO:	DoAll
				DoExpr {$qcolo_startlocal=getdatetimelocal[]}
				DoExpr {$qcolo_start=getunixtime[]}
				DoExpr {$qcolo_roomtimes=dictcreate[]}
				DoExpr {echo[`[META]: Entering First Room of the Colosseum @ `+$qcolo_startlocal,19]}
	~~ first lets go into the arena, so that we can start our timer
	IF:	All
			NavEmpty
			Expr {$portal=listgetitem[wobjectfindalllandscapebytemplatetype[34728],0]}
		DO: DoAll
				DoExpr {actiontryuseitem[$portal]}
				DoExpr {$qcolo_roomnumber=5}
				SetWatchdog 2 2 {EnterFirstRoom}
	~~ clear the watchdog when we enter the portal so it doesn't accidentally trip right after we exit
	IF:	Any
			IntoPortal
			Expr {isportaling[]}
		DO:	ClearWatchdog
	~~ ok we zoned into the arena, and we're actually going to start buffing
	IF:	ExitPortal
		DO:	SetState {BuffingBeforeRun}
~~ }
STATE: {BuffingBeforeRun} ~~ {
	IF:	Always
		DO:	DoAll
				DoExpr {ifthen[&qcolo_managed_encaps&&getinventorycountbytemplatetype[49485]>50,`chatbox[\`/vt opt set summonpets true\`]`,`chatbox[\`/vt opt set summonpets false\`]`]}
				DoExpr {$qcolo_buffed=((listreduce[getknownspells[],`$2+iif[getspellexpiration[$1]>12000,0,getspellexpiration[$1]]`]/listreduce[getknownspells[],`$2+iif[getspellexpiration[$1]>12000||getspellexpiration[$1]==0,0,1]`])>3600)}
				DoExpr {echo[`[META]: Buffing before Colosseum Run`,19]}
	~~ if we've been buffing for 3 minutes, or we finished by casting Blackmoor's Favor, or we have buffing turned off, or our buffs are going to last an hour, then we're good to go.. probably
	IF:	Any
			Not Expr {&qcolo_enablebuffing}
			SecsInStateGE 180
			ChatMatch {^You cast Blackmoor.*s Favor on yourself}
			Expr {testvar[qcolo_buffed]&&$qcolo_buffed}
		DO:	SetState {SynchronizeAfterBuffing}
	~~ first lets go into the arena, so that we can start our timer
	IF:	Not Expr {testvar[qcolo_buffed]&&$qcolo_buffed}
		DO:	DoAll
				Chat {/vt forcebuff}
				SetOpt {EnableBuffing} {true}
~~ }
STATE: {SynchronizeAfterBuffing} ~~ {
	IF: Always
		DO:	DoExpr {echo[`[META]: Synchronizing all Characters @ Finished Buffing`,19]}
	IF:	All
			Expr {listcontains[&qcolo_charsbuffed,getcharstringprop[1]]||listadd[&qcolo_charsbuffed,getcharstringprop[1]]}
			Never
		DO:	None
	IF: Expr {listcount[&qcolo_charsbuffed]>=listcount[&qcolo_chars]}
		DO:	DoAll
				DoExpr {echo[`[META]: Synchronized `+listcount[&qcolo_charsbuffed]+` Characters @ Finished Buffing`,19]}
				Chat {/ub myquests}
				SetState {StartCurrentRoom}
~~ }
STATE: {StartCurrentRoom} ~~ {
	IF:	Always
		DO:	DoExpr {echo[`[META]: Setting up for Colosseum Room: `+cstr[$qcolo_roomnumber+1],19]}
	~~ ring the bell, start killing & looting
	IF:	Always
		DO:	DoAll
				DoExpr {setvar[qcolo_roomnumber,$qcolo_roomnumber+1]}
				DoExpr {$qcolo_roomstart=getunixtime[]}
				SetOpt {EnableCombat} {true}
				SetOpt {EnableLooting} {true}
				Chat {/ub usel Arena Bell}
				SetState {KillingCurrentRoom}
~~ }
STATE: {KillingCurrentRoom} ~~ {
	IF:	Always
		DO:	DoExpr {echo[`[META]: Starting Battle in Colosseum Room: `+$qcolo_roomnumber,19]}
	IF: Death
		DO: DoAll
				DoExpr {echo[`[META]: Died in Colosseum Room: `+$qcolo_roomnumber,19]}
				SetState {ProgressCheck}
	IF:	Any
			ChatMatch {A Door appears on the North wall.}
			ChatMatch {Congratulations! You have beaten the Colosseum!}
			Expr {wobjectfindnearestbyobjectclass[14]&&coordinatedistancewithz[getplayercoordinates[], wobjectgetphysicscoordinates[wobjectfindnearestbyobjectclass[14]]]<=29}
		DO:	DoAll
				DoExpr {$qcolo_roomfinish=getunixtime[]}
				DoExpr {$qcolo_roomelapsed=$qcolo_roomfinish-$qcolo_roomstart}
				DoExpr {$qcolo_roomtimetocomplete=cstr[floor[($qcolo_roomelapsed)/60]]+`m`+cstr[floor[($qcolo_roomelapsed)%60)]]+`s`}
				DoExpr {dictadditem[$qcolo_roomtimes,cstr[$qcolo_roomnumber],$qcolo_roomtimetocomplete]}
				SetState {MoveToNextRoom}
~~ }
STATE: {MoveToNextRoom} ~~ {
	IF:	Always
		DO:	DoAll
				DoExpr {echo[`[META]: Moving to Colosseum Room: `+cstr[$qcolo_roomnumber+1],19]}
				DoExpr {echo[`[META]: Time Spent in Room #`+cstr[$qcolo_roomnumber]+`: `+$qcolo_roomtimetocomplete,19]}
	~~ once we enter the portal, don't try to use it anymore	~~ if we try to start the room, but we finished the run, then wait for our timer
	IF:	Any
			CellE 00AF0118
			CellE 00AF0117
		DO:	DoAll
				DoExpr {$qcolo_finish=getunixtime[]}
				DoExpr {$qcolo_finishlocal=getdatetimelocal[]}
				DoExpr {$qcolo_elapsed=$qcolo_finish-$qcolo_start}
				DoExpr {$qcolo_timetocomplete=cstr[floor[($qcolo_elapsed)/60]]+`m`+cstr[floor[($qcolo_elapsed)%60)]]+`s`}
				DoExpr {echo[`[META]: Completed the Colosseum @ `+$qcolo_finishlocal,19]}
				SetState {WaitingForRewards}
	IF:	ExitPortal
		DO:	SetState {StartCurrentRoom}
	~~ turn off looting and use the nearest portal.. over and over until it works
	IF:	Not Expr {isportaling[]}
		DO:	DoAll
				SetOpt {EnableLooting} {false}
				SetOpt {EnableCombat} {false}
				DoExpr {actiontryuseitem[wobjectfindnearestbyobjectclass[14]]}
				SetWatchdog 2 2 {MoveToNextRoom}
~~ }
STATE: {WaitingForRewards} ~~ {
	IF:	Always
		DO:	DoAll
				DoExpr {echo[`[META]: Waiting for Rewards Timer to Run Out`,19]}
				DoExpr {echo[`[META]: Total Colosseum Run Time: `+$qcolo_timetocomplete,19]}
	~~ if we started colo and we're at this step, then lets see if we're ready for turn in
	IF:	Always
		DO:	Chat {/ub myquests}
	~~ keep checking every 30 seconds
	IF:	SecsInStateGE 30
		DO:	SetState {WaitingForRewards}
	~~ if all our flags are good, we can finally turn in!
	IF:	All
			Not Expr {isrefreshingquests[]}
			Expr {getqueststatus[coloarenaoneaccess]}
			Expr {getqueststatus[coloarenatwoaccess]}
			Expr {getqueststatus[coloarenathreeaccess]}
			Expr {getqueststatus[coloarenafouraccess]}
			Expr {getqueststatus[coloarenafiveaccess]}
		DO:	SetState {SynchronizeRewardTurnIn}
~~ }
STATE: {SynchronizeRewardTurnIn} ~~ {
	IF: Always
		DO:	DoExpr {echo[`[META]: Synchronizing all Characters @ Reward Turn In`,19]}
	IF:	All
			Expr {listcontains[&qcolo_charsreadyforturnin,getcharstringprop[1]]||listadd[&qcolo_charsreadyforturnin,getcharstringprop[1]]}
			Never
		DO:	None
	IF: Expr {listcount[&qcolo_charsreadyforturnin]>=listcount[&qcolo_chars]}
		DO:	DoAll
				DoExpr {echo[`[META]: Synchronized `+listcount[&qcolo_charsreadyforturnin]+` Characters @ Reward Turn In`,19]}
				SetState {TurnInRewards}
~~ }
STATE: {TurnInRewards} ~~ {
	IF:	Always
		DO:	DoExpr {echo[`[META]: Collecting Rewards from Master Arbitrator`,19]}
	~~ this actually gets us the reward
	IF:	SecsInStateGE 3
		DO:	DoAll
				DoExpr {setgvar[qcolo_charsbuffed,listcreate[]]}
				DoExpr {setgvar[qcolo_charswaiting,listcreate[]]}
				DoExpr {setgvar[qcolo_fellowlocked,0]}
				DoExpr {clearvar[qcolo_buffed]}
				EmbedNav navTalkMasterArbitrator {TalkMasterArbitrator}
	~~ if we think we're done but we're not, well keep on going.
	IF:	ChatMatch {Master Arbitrator tells you\, \"Your fellowship\'s Arena battles still continue. }
		DO:	SetState {EnterFirstRoom}
	~~ these conditions trigger a restart
	IF:	Any
			ChatMatch {Master Arbitrator tells you\, \"If you wish to fight as a gladiator in the Arena}
			ChatMatch {You\'ve earned .* experience\.}
		DO:	SetState {WaitingForCommands}
~~ }
STATE: {BuyTickets} ~~ {
	IF: ItemCountLE 5 {Trade Note (250,000)}
		DO: DoAll
				DoExpr {echo[`[ERROR]: Not Enough MMD Notes to Buy More Tickets!`,21]}
				SetState {WaitingForCommands}
	IF:	ItemCountGE 12 {Colosseum Ticket}
		DO:	SetState {WaitingForCommands}
	IF:	ItemCountLE 11 {Colosseum Ticket}
		DO:	DoAll
				Chat {/ub give 1 Trade Note (250,000) to Colosseum Ticket Vendor}
				SetState {BuyTickets}
~~ }
STATE: {AnnounceRoomTimes} ~~ {
	IF:	Always
		DO:	DoAll
				DoExpr {echo[`[META]: Announcing Last Colo Run Times`,19]}
				DoExpr {echo[`[META]: Started the Colosseum @ `+$qcolo_startlocal,19]}
				DoExpr {echo[`[META]: Completed the Colosseum @ `+$qcolo_finishlocal,19]}
				DoExpr {echo[`[META]: Total Colosseum Run Time: `+$qcolo_timetocomplete,19]}
				DoExpr {$roomnumbers=listfromrange[1,18]}
				DoExpr {listreduce[$roomnumbers,`dicthaskey[$qcolo_roomtimes,cstr[$1]]&&echo[\`[META]: Room # \`+$1+\` - Time : \`+dictgetitem[$qcolo_roomtimes,cstr[$1]],19]`]}
				SetState {WaitingForCommands}
~~ }
~~========================= ONLY NAVS APPEAR BELOW THIS LINE =========================~~

NAV: navNone once ~~ {
~~ }
NAV: navTalkMasterArbitrator once ~~ {
	pnt -101.783239634832 38.0445641900102 2.08333134651184E-05
	tlk -101.783916680018 37.9945620814959 2.08333134651184E-05 -101.783333333333 38.05 3.12502197630238E-05 37 {Master Arbitrator}
~~ }